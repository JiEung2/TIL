# List
## 배열
### 배열이란 무엇인가
- 일정한 자료형의 변수들을 하나의 이름으로 열거하여 사용하는 자료구조

### 배열의 필요성
- 프로그램 내에서 여러 개의 변수가 필요할 때, 일일이 다른 변수명을 이용하여 자료에 접근하는 것은 매우 비효율적일 수 있음
- 배열을 사용하면 하나의 선언을 통해서 둘 이상의 변수를 선언할 수 있음
- 단순히 다수의 변수 선언을 의미하는 것이 아니라, 다수의 변수로는 하기 힘든 작업을 배열을 활용해 쉽게 할 수 있음

## 정렬
- 2개 이상의 자료를 특정 기준에 의해 작은 값부터 큰 값(오름차순), 혹은 그 반대의 순서대로(내림차순) 재배열하는 것
- 키
  - 자료를 정렬하는 기준이 되는 특정 값

### 정렬의 종류
- 대표적인 정렬 방식의 종류
  - 버블 정렬 (Bubble Sort)
  - 카운팅 정렬 (Counting Sort)
  - 선택 정렬 (Selection Sort)
  - 퀵 정렬 (Quick Sort)
  - 삽입 정렬 (Insertion Sort)
  - 병합 정렬 (Merge Sort)

### 버블 정렬
- 인접한 두 개의 원소를 비교하며 자리를 계속 교환하는 방식
- 정렬 과정
  - 첫 번째 원소부터 인접한 원소끼리 계속 자리를 교환하면서 맨 마지막 자리까지 이동
  - 한 단계가 끝나면 가장 큰 원소가 마지막 자리로 정렬됨
  - 교환하며 자리를 이동하는 모습이 물 위에 올라오는 거품 모양과 같다고 하여 버블 정렬이라고 함
- 시간 복잡도: O(n^2)

- 배열을 활용한 버블 정렬
**pseudo code**
```
BubbleSort(a, N)          # 정렬할 배열과 배열의 크기
    for i : N-1 -> 1      # 정렬될 구간의 끝
      for j : 0 -> i-1    # 비교할 원소 중 왼쪽 원소의 인덱스
        if a[j] > a[j+1]  # 왼쪽 원소가 더 크면
          a[j] <-> a[j+1] # 오른쪽 원소와 교환
```
```py
def BubbleSort(a, N):
    for i in range(N-1, 0, -1)
        for j in range(0, i):
            if a[j] > a[j+1]:
                a[j], a[j+1] = a[j+1], a[j]
```

### 카운팅 정렬
- 항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하여, 선형 시간에 정렬하는 효율적인 알고리즘
- 제한 사항
  - 정수나 정수로 표현할 수 있는 자료에 대해서만 적용 가능: 각 항목의 발생 회수를 기록하기 위해, 정수 항목으로 인덱스 되는 카운트들의 배열을 사용하기 때문
  - 카운트들을 위한 충분한 공간을 할당하려면 집합 내의 가장 큰 정수를 알아야 함
- 시간 복잡도: O(n + k): n은 리스트 길이, k는 정수의 최대값

### 카운팅 정렬 과정
- 1단계
  - Data에서 각 항목들의 발생 회수를 세고, 정수 항목들로 직접 인덱스 되는 카운트 배열 counts에 저장  
  ![!\[Alt text\](image.png)](List-1.png)
  - 정렬된 집합에서 각 항목의 앞에 위치할 항목의 개수를 반영하기 위해 counts의 원소를 조정  
  ![!\[Alt text\](image.png)](List-2.png)
  - counts[1]을 감소시키고 Temp에 1을 삽입  
  ![!\[Alt text\](image.png)](List-3.png)
  - counts[4]를 감소시키고 Temp에 4를 삽입  
  ![!\[Alt text\](image.png)](List-4.png)
  - 이렇게 반복해서 Temp를 완성

```py
def Counting_Sort(DATA, TEMP, k)
# DATA [] -- 입력 배열(0 to k)
# TEMP [] -- 정렬된 배열
# COUNTS[] -- 카운트 배열

    COUNTS = [0] * (k+1)
    
    for i in range (0, len(DATA)):
        COUNTS[DATA[i]] += 1
    
    for i in range (1, k+1):
        COUNTS[i] += COUNTS[i-1]
    
    for i in range (len(TEMP)-1, -1, -1):
        COUNTS[DATA[i]] -= 1
        TEMP[COUNTS[DATA[i]]] = DATA[i]
```

### 정렬 알고리즘 비교
|알고리즘|평균 수행시간|최악 수행시간|알고리즘 기법|비고|
|:---:|:---:|:---:|:---:|:---:|
|버블 정렬|O(n^2)|O(n^2)|비교와 교환|코딩이 가장 손쉬움|
|카운팅 정렬|O(n+k)|O(n+k)|비교환 방식|n이 비교적 작을 때만 가능|
|선택 정렬|O(n^2)|O(n^2)|비교와 교환|교환의 횟수가 버블, 삽입 정렬보다 작음|
|퀵 정렬|O(n log n)|O(n^2)|분할 정복|최악의 경우 O(n^2)이지만, 평균적으로 가장 빠름|
|삽입 정렬|O(n^2)|O(n^2)|비교와 교환|n의 개수가 작을 때 효과적|
|병합 정렬|O(n log n)|O(n log n)|분할 정복|연결리스트의 경우 가장 효율적인 방식|

### 완전 검색(Exaustive Search)
- 완전 검색 방법은 문제의 해법으로 생각할 수 있는 `모든 경우의 수를 나열해보고 확인하는 기법`
- Brute-force 혹은 generate-and-test 기법이라고도 불림
- 모든 경우의 수를 테스트한 후, 최종 해법을 도출
- 일반적으로 경우의 수가 상대적으로 작을 때 유용
- 모든 경우의 수를 생성하고 테스트하기 때문에 '수행 속도는 느리지만, 해답을 찾아내지 못할 확률이 작음
- 주어진 문제를 풀 때, 우선 완전 검색으로 접근하여 해답을 도출한 후, 성능 개선을 위해 다른 알고리즘을 사용하고 해답을 확인하는 것이 바람직

### 순열
- 서로 다른 것들 중 몇 개를 뽑아서 한 줄로 나열하는 것
- 서로 다른 n개 중 r개를 택하는 순열은 nPr 로 표현
- 그리고 nPr은 다음과 같은 식이 성립 -> nPr = n * (n-1) * (n-2) * ... * (n-r+1)
- nPn = n!이라고 표기
- ex) {1, 2, 3}을 포함하는 모든 순열을 생성하는 함수
  - 동일한 숫자가 포함되지 않았을 때, 각 자리 수 별로 반복문을 이용해 구현 가능
  - 그냥 3중 for문 돌려서

### 그리디(탐욕) 알고리즘
- 그리디 알고리즘은 최적해를 구하는 데 사용되는 근시안적인 방법
- 여러 경우 중 하나를 결정해야 할 때마다 그 순간에 최적이라고 생각되는 것을 선택해 나가는 방식으로 진행하여 최종적인 해답에 도달
- 각 선택의 시점에서 이루어지는 결정은 지역적으로는 최적이지만, 그 선택들을 계속 수집하여 최종적인 해답을 만들었다고 하여, 그것이 최적이라는 보장은 없음
- 일반적으로, 머리 속에 떠오르는 생각을 검증 없이 바로 구현하면 그리디 접근이 됨

### 그리디 알고리즘의 동작 과정
1) 해 선택: 현재 상테에서 부분 문제의 최적 해를 구한 뒤, 이를 분분해 집합(Solution Set)에 추가
2) 실행 가능성 검사: 새로운 부분해 집합이 실행 가능한지를 확인. 곧, 문제의 제약 조건을 위반하지 않는지를 검사
3) 해 검사: 새로운 부분해 집합이 문제의 해가 되는지를 확인. 아직 전체 문제의 해가 완성되지 않았다면 1)의 해 선택부터 다시 시작


## 배열 2(Array 2)
- 1차원 List를 묶어놓은 List
- 2차원 이상의 다차원 List는 차원에 따라 Index를 선언
- 2차원 List의 선언: 세로길이(행의 개수), 가로길이(열의 개수)를 필요로 함
- Python에서는 데이터 초기화를 통해 변수선언과 초기화가 가느앟ㅁ

### 배열 순회
- n x m 배열의 n*m개의 모든 원소를 빠짐없이 조사하는 방법

### 행 우선 순회
```py
for i in range(n):
    for j in range(m):
        f(array[i][j]) # 필요한 연산 수행
```

### 열 우선 순회
```py
for j in range(m):
    for i in range(n):
        f(array[i][j]) # 필요한 연산 수행
```

### 지그재그 순회
```py
# ->
# <-
for i in range(n):
    for j in range(m):
        f(array[i][j + (m-1-2*j) * (i%2)])
```

### 델타를 이용한 2차 배열 탐색
- 2차 배열의 한 좌표에서 4방향의 인접 배열 요소를 탐색하는 방법
- 인덱스 (i, j)인 칸의 상하좌우 칸(ni, nj)
- 방향 확인하는 거 dx dy해서 그거임
```
arr[0...N-1][0...N-1] # NxN 배열
di[] <- [0, 1, 0, -1]
dj[] <- [1, 0, -1, 0]
for i : 0 -> N-1:
    for j : 0 -> N-1:
        for k in range(4):
            ni <- j + di[k]
            nj <- j + dj[k]
            if 0 <= ni < N and 0 <= nj < N # 유효한 인덱스면
                f(arr[ni][nj])
```

### 전치 행렬
```py
# i : 행의 좌표, len(arr)
# j : 열의 좌표, len(arr[0])
arr = [[1,2,3],[4,5,6],[7,8,9]] # 3*3 행렬

for i in range(3):
    for j in range(3):
        if i < j:
            arr[i][j], arr[j][i] = arr[j][i], arr[i][j]
```

### 부분집합 합(Subset Sum)문제
- 유한 개의 정수로 이루어진 집합이 있을 때, 이 집합의 부분집합 중에서 그 집합의 원소를 모두 더한 값이 0이 되는 경우가 있는지를 알아내는 문제
- 예를 들어, [-7, -3, -2, 5, 8]라는 집합이 있을 때, [-3, -2, -5]는 이 집합의 부분집합이면서 (-3)+(-2)+5=0이므로 이 경우 답은 참이 된다.

### 부분집합 생성하기
- 완전검색 기법으로 부분집합 합 문제를 풀기 위해서는, 우선 집합의 모든 부분집합을 생성한 후에 각 부분집합의 합을 계산해야 한다.
- 주어진 집합의 부분집합을 생성하는 방법에 대해서 생각해보자.

- 부분집합의 수
  - 집합의 원소가 n개일 때, 공집합을 포함한 부분집합의 수는 2^n개이다.
  - 이는 각 원소를 부분집합에 포함시키거나 포함시키지 않는 2가지 경우를 모든 원소에 적용한 경우의 수와 같다.

- 각 원소가 부분집합에 포함되었는지를 loop를 이용하여 확인하고 부분집합을 생성하는 방법
```py
bit = [0, 0, 0, 0]
for i in range(2):
    bit[0] = i
    for j in range(2):
        bit[1] = j
        for k in range(2):
            bit[2] = k
            for l in range(2):
                bit[3] = l
                print_subset(bit)
```

### 비트 연산자
- 비트 연산자
  - & 비트 단위로 AND 연산
  - | 비트 단위로 OR 연산
  - << 피연산자의 비트 열을 왼쪽으로 이동
  - >> 피연산자의 비트 열을 오른쪽으로 이동

- << 연산자
  - 1 << n: 2^n 즉, 원소가 n개일 경우의 모든 부분집합의 수를 의미

- & 연산자
  - i & (1 << j): i의 j번째 비트가 1인지 아닌지를 검사 

### 간결하게 부분집합을 생성하는 방법
```py
arr = [3,6,7,1,5,4]

n = len(arr)

for i in range(1 << n):   # 1 << n: 부분 집합의 개수
    for j in range(n):    # 원소의 수만큼 비트를 비교함
        if i & (1 << j):  # i의 j번 비트가 1인 경우
            print(arr[j], end=", ")   # j번 원소 출력
    print()
print()
```