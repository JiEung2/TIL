# List
## 배열
### 배열이란 무엇인가
- 일정한 자료형의 변수들을 하나의 이름으로 열거하여 사용하는 자료구조

### 배열의 필요성
- 프로그램 내에서 여러 개의 변수가 필요할 때, 일일이 다른 변수명을 이용하여 자료에 접근하는 것은 매우 비효율적일 수 있음
- 배열을 사용하면 하나의 선언을 통해서 둘 이상의 변수를 선언할 수 있음
- 단순히 다수의 변수 선언을 의미하는 것이 아니라, 다수의 변수로는 하기 힘든 작업을 배열을 활용해 쉽게 할 수 있음

## 정렬
- 2개 이상의 자료를 특정 기준에 의해 작은 값부터 큰 값(오름차순), 혹은 그 반대의 순서대로(내림차순) 재배열하는 것
- 키
  - 자료를 정렬하는 기준이 되는 특정 값

### 정렬의 종류
- 대표적인 정렬 방식의 종류
  - 버블 정렬 (Bubble Sort)
  - 카운팅 정렬 (Counting Sort)
  - 선택 정렬 (Selection Sort)
  - 퀵 정렬 (Quick Sort)
  - 삽입 정렬 (Insertion Sort)
  - 병합 정렬 (Merge Sort)

### 버블 정렬
- 인접한 두 개의 원소를 비교하며 자리를 계속 교환하는 방식
- 정렬 과정
  - 첫 번째 원소부터 인접한 원소끼리 계속 자리를 교환하면서 맨 마지막 자리까지 이동
  - 한 단계가 끝나면 가장 큰 원소가 마지막 자리로 정렬됨
  - 교환하며 자리를 이동하는 모습이 물 위에 올라오는 거품 모양과 같다고 하여 버블 정렬이라고 함
- 시간 복잡도: O(n^2)

- 배열을 활용한 버블 정렬
**pseudo code**
```
BubbleSort(a, N)          # 정렬할 배열과 배열의 크기
    for i : N-1 -> 1      # 정렬될 구간의 끝
      for j : 0 -> i-1    # 비교할 원소 중 왼쪽 원소의 인덱스
        if a[j] > a[j+1]  # 왼쪽 원소가 더 크면
          a[j] <-> a[j+1] # 오른쪽 원소와 교환
```
```py
def BubbleSort(a, N):
    for i in range(N-1, 0, -1)
        for j in range(0, i):
            if a[j] > a[j+1]:
                a[j], a[j+1] = a[j+1], a[j]
```

### 카운팅 정렬
- 항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하여, 선형 시간에 정렬하는 효율적인 알고리즘
- 제한 사항
  - 정수나 정수로 표현할 수 있는 자료에 대해서만 적용 가능: 각 항목의 발생 회수를 기록하기 위해, 정수 항목으로 인덱스 되는 카운트들의 배열을 사용하기 때문
  - 카운트들을 위한 충분한 공간을 할당하려면 집합 내의 가장 큰 정수를 알아야 함
- 시간 복잡도: O(n + k): n은 리스트 길이, k는 정수의 최대값

### 카운팅 정렬 과정
- 1단계
  - Data에서 각 항목들의 발생 회수를 세고, 정수 항목들로 직접 인덱스 되는 카운트 배열 counts에 저장  
  ![!\[Alt text\](image.png)](List-1.png)
  - 정렬된 집합에서 각 항목의 앞에 위치할 항목의 개수를 반영하기 위해 counts의 원소를 조정  
  ![!\[Alt text\](image.png)](List-2.png)
  - counts[1]을 감소시키고 Temp에 1을 삽입  
  ![!\[Alt text\](image.png)](List-3.png)
  - counts[4]를 감소시키고 Temp에 4를 삽입  
  ![!\[Alt text\](image.png)](List-4.png)
  - 이렇게 반복해서 Temp를 완성

```py
def Counting_Sort(DATA, TEMP, k)
# DATA [] -- 입력 배열(0 to k)
# TEMP [] -- 정렬된 배열
# COUNTS[] -- 카운트 배열

    COUNTS = [0] * (k+1)
    
    for i in range (0, len(DATA)):
        COUNTS[DATA[i]] += 1
    
    for i in range (1, k+1):
        COUNTS[i] += COUNTS[i-1]
    
    for i in range (len(TEMP)-1, -1, -1):
        COUNTS[DATA[i]] -= 1
        TEMP[COUNTS[DATA[i]]] = DATA[i]
```

### 정렬 알고리즘 비교
|알고리즘|평균 수행시간|최악 수행시간|알고리즘 기법|비고|
|:---:|:---:|:---:|:---:|:---:|
|버블 정렬|O(n^2)|O(n^2)|비교와 교환|코딩이 가장 손쉬움|
|카운팅 정렬|O(n+k)|O(n+k)|비교환 방식|n이 비교적 작을 때만 가능|
|선택 정렬|O(n^2)|O(n^2)|비교와 교환|교환의 횟수가 버블, 삽입 정렬보다 작음|
|퀵 정렬|O(n log n)|O(n^2)|분할 정복|최악의 경우 O(n^2)이지만, 평균적으로 가장 빠름|
|삽입 정렬|O(n^2)|O(n^2)|비교와 교환|n의 개수가 작을 때 효과적|
|병합 정렬|O(n log n)|O(n log n)|분할 정복|연결리스트의 경우 가장 효율적인 방식|

### 완전 검색(Exaustive Search)
- 완전 검색 방법은 문제의 해법으로 생각할 수 있는 `모든 경우의 수를 나열해보고 확인하는 기법`
- Brute-force 혹은 generate-and-test 기법이라고도 불림
- 모든 경우의 수를 테스트한 후, 최종 해법을 도출
- 일반적으로 경우의 수가 상대적으로 작을 때 유용
- 모든 경우의 수를 생성하고 테스트하기 때문에 '수행 속도는 느리지만, 해답을 찾아내지 못할 확률이 작음
- 주어진 문제를 풀 때, 우선 완전 검색으로 접근하여 해답을 도출한 후, 성능 개선을 위해 다른 알고리즘을 사용하고 해답을 확인하는 것이 바람직

### 순열
- 서로 다른 것들 중 몇 개를 뽑아서 한 줄로 나열하는 것
- 서로 다른 n개 중 r개를 택하는 순열은 nPr 로 표현
- 그리고 nPr은 다음과 같은 식이 성립 -> nPr = n * (n-1) * (n-2) * ... * (n-r+1)
- nPn = n!이라고 표기
- ex) {1, 2, 3}을 포함하는 모든 순열을 생성하는 함수
  - 동일한 숫자가 포함되지 않았을 때, 각 자리 수 별로 반복문을 이용해 구현 가능
  - 그냥 3중 for문 돌려서

### 그리디(탐욕) 알고리즘
- 그리디 알고리즘은 최적해를 구하는 데 사용되는 근시안적인 방법
- 여러 경우 중 하나를 결정해야 할 때마다 그 순간에 최적이라고 생각되는 것을 선택해 나가는 방식으로 진행하여 최종적인 해답에 도달
- 각 선택의 시점에서 이루어지는 결정은 지역적으로는 최적이지만, 그 선택들을 계속 수집하여 최종적인 해답을 만들었다고 하여, 그것이 최적이라는 보장은 없음
- 일반적으로, 머리 속에 떠오르는 생각을 검증 없이 바로 구현하면 그리디 접근이 됨

### 그리디 알고리즘의 동작 과정
1) 해 선택: 현재 상테에서 부분 문제의 최적 해를 구한 뒤, 이를 분분해 집합(Solution Set)에 추가
2) 실행 가능성 검사: 새로운 부분해 집합이 실행 가능한지를 확인. 곧, 문제의 제약 조건을 위반하지 않는지를 검사
3) 해 검사: 새로운 부분해 집합이 문제의 해가 되는지를 확인. 아직 전체 문제의 해가 완성되지 않았다면 1)의 해 선택부터 다시 시작


## 배열 2(Array 2)
- 1차원 List를 묶어놓은 List
- 2차원 이상의 다차원 List는 차원에 따라 Index를 선언
- 2차원 List의 선언: 세로길이(행의 개수), 가로길이(열의 개수)를 필요로 함
- Python에서는 데이터 초기화를 통해 변수선언과 초기화가 가느앟ㅁ

### 배열 순회
- n x m 배열의 n*m개의 모든 원소를 빠짐없이 조사하는 방법

### 행 우선 순회
```py
for i in range(n):
    for j in range(m):
        f(array[i][j]) # 필요한 연산 수행
```

### 열 우선 순회
```py
for j in range(m):
    for i in range(n):
        f(array[i][j]) # 필요한 연산 수행
```

### 지그재그 순회
```py
# ->
# <-
for i in range(n):
    for j in range(m):
        f(array[i][j + (m-1-2*j) * (i%2)])
```

### 델타를 이용한 2차 배열 탐색
- 2차 배열의 한 좌표에서 4방향의 인접 배열 요소를 탐색하는 방법
- 인덱스 (i, j)인 칸의 상하좌우 칸(ni, nj)
- 방향 확인하는 거 dx dy해서 그거임
```
arr[0...N-1][0...N-1] # NxN 배열
di[] <- [0, 1, 0, -1]
dj[] <- [1, 0, -1, 0]
for i : 0 -> N-1:
    for j : 0 -> N-1:
        for k in range(4):
            ni <- j + di[k]
            nj <- j + dj[k]
            if 0 <= ni < N and 0 <= nj < N # 유효한 인덱스면
                f(arr[ni][nj])
```

### 전치 행렬
```py
# i : 행의 좌표, len(arr)
# j : 열의 좌표, len(arr[0])
arr = [[1,2,3],[4,5,6],[7,8,9]] # 3*3 행렬

for i in range(3):
    for j in range(3):
        if i < j:
            arr[i][j], arr[j][i] = arr[j][i], arr[i][j]
```

### 부분집합 합(Subset Sum)문제
- 유한 개의 정수로 이루어진 집합이 있을 때, 이 집합의 부분집합 중에서 그 집합의 원소를 모두 더한 값이 0이 되는 경우가 있는지를 알아내는 문제
- 예를 들어, [-7, -3, -2, 5, 8]라는 집합이 있을 때, [-3, -2, -5]는 이 집합의 부분집합이면서 (-3)+(-2)+5=0이므로 이 경우 답은 참이 된다.

### 부분집합 생성하기
- 완전검색 기법으로 부분집합 합 문제를 풀기 위해서는, 우선 집합의 모든 부분집합을 생성한 후에 각 부분집합의 합을 계산해야 한다.
- 주어진 집합의 부분집합을 생성하는 방법에 대해서 생각해보자.

- 부분집합의 수
  - 집합의 원소가 n개일 때, 공집합을 포함한 부분집합의 수는 2^n개이다.
  - 이는 각 원소를 부분집합에 포함시키거나 포함시키지 않는 2가지 경우를 모든 원소에 적용한 경우의 수와 같다.

- 각 원소가 부분집합에 포함되었는지를 loop를 이용하여 확인하고 부분집합을 생성하는 방법
```py
bit = [0, 0, 0, 0]
for i in range(2):
    bit[0] = i
    for j in range(2):
        bit[1] = j
        for k in range(2):
            bit[2] = k
            for l in range(2):
                bit[3] = l
                print_subset(bit)
```

### 비트 연산자
- 비트 연산자
  - & 비트 단위로 AND 연산
  - | 비트 단위로 OR 연산
  - << 피연산자의 비트 열을 왼쪽으로 이동
  - >> 피연산자의 비트 열을 오른쪽으로 이동

- << 연산자
  - 1 << n: 2^n 즉, 원소가 n개일 경우의 모든 부분집합의 수를 의미

- & 연산자
  - i & (1 << j): i의 j번째 비트가 1인지 아닌지를 검사 

### 간결하게 부분집합을 생성하는 방법
```py
arr = [3,6,7,1,5,4]

n = len(arr)

for i in range(1 << n):   # 1 << n: 부분 집합의 개수
    for j in range(n):    # 원소의 수만큼 비트를 비교함
        if i & (1 << j):  # i의 j번 비트가 1인 경우
            print(arr[j], end=", ")   # j번 원소 출력
    print()
print()
```

## 검색
- 저장되어 있는 자료 중에서 원하는 항목을 찾는 작업
- 목적하는 탐색 키를 가진 항목을 찾는 것
  - 탐색 키(search key): 자료를 구별하여 인식할 수 있는 ㅣㅋ
- 검색의 종류
  - 순차 검색(sequential search)
  - 이진 검색(binary search)
  - 해쉬(hash)

### 순차 검색(Sequential Search)
- 일렬로 되어 있는 자료를 순서대로 검색하는 방법
  - 가장 간단하고 직관적인 검색 방법
  - 배열이나 연결 리스트 등 순차 구조로 구현된 자료구조에서 원하는 항목을 찾을 때 유용함
  - 알고리즘이 단순하여 구현이 쉽지만, 검색 대상의 수가 많은 경우에는 수행시간이 급격히 증가하여 비효율적임
- 2가지 경우
  - 정렬되어 있지 않은 경우
  - 정렬되어 있는 경우

- 검색 과정
  - 첫 번째 원소부터 순서대로 검색 대상과 키 값이 같은 원소가 있는지 비교하며 찾음
  - 키 값이 동일한 원소를 찾으면 그 원소의 인덱스를 반환
  - 자료구조의 마지막에 이를 때까지 검색 대상을 찾지 못하면 검색 실패

### 정렬되어 있지 않은 경우
- 찾고자 하는 원소의 순서에 따라 비교회수가 결정됨
  - 첫 번째 원소를 찾을 때는 1번 비교, 두 번째 원소를 찾을 때는 2번 비교
  - 정렬되지 않은 자료에서의 순차 검색의 평균 비교 회수
    - = (1/n)*(1+2+3+...+n) = (n+1)/2
  - 시간 복잡도: O(n)
- 구현 예
```
def sequential_search(a, n, key)
    i <- 0
    while i<n and a[i]!=key:
        i <- i+1
    if i<n: return i
    else: return -1
```

### 정렬되어 있는 경우
- 검색 과정
  - 자료가 오름차순으로 정렬된 상태에서 검색을 실시한다고 가정
  - 자료를 순차적으로 검색하면서 키 값을 비교하여, 원소의 키 값이 검색 대상의 키 값보다 크면 찾는 원소가 없다는 것이므로 더 이상 검색하지 않고 검색을 종료
- 찾고자 하는 원소의 순서에 따라 비교회수가 결정됨
  - 정렬이 되어있으므로, 검색 실패를 반환하는 경우 평균 비교 회수가 반으로 줄어듦
  - 시간 복잡도: O(n)
- 구현 예
```
def sequentialSearch(a, n, key)
    i <- 0
    while i<n and a[i] < key :
        i <- i + 1
    if i < n and a[i] == key:
        return i
    else:
        return -1
```

## 이진 검색(Binary Search)
- 자료의 가운데에 있는 항목의 키 값과 비교하여 다음 검색의 위치를 결정하고 검색을 계속 진행하는 방법
  - 목적 키를 찾을 때까지 이진 검색을 순환적으로 반복 수행함으로써 검색 범위를 반으로 줄여가면서 보다 빠르게 검색을 수행

- 이진 검색을 하기 위해서는 자료가 정렬된 상태여야 함

- 검색 과정
  - 자료의 중앙에 있는 원소를 고름
  - 중앙 원소의 값과 찾고자 하는 목표 값을 비교
  - 목표 값이 중앙 원소의 값보다 작으면 자료의 왼쪽 반에 대해서 새로 검색을 수행하고, 크다면 자료의 오른쪽 반에 대해서 새로 검색을 수행
  - 찾고자 하는 값을 찾을 때까지 1~3의 과정을 반복

- 구현
  - 검색 범위의 시작점과 종료점을 이용하여 검색을 반복 수행
  - 이진 검색의 경우, 자료에 삽입이나 삭제가 발생했을 때 배열의 상태를 항상 정렬 상태로 유지하는 추가 작업이 필요

```
def binarySearch(a, N, key)
    start = 0
    end = N-1
    while start <= end:
        middle = (start + end) // 2
        if a[middle] == key:
            return true
        elif a[middle] > key:
            end = middle - 1
        else:
            start = middle + 1
    return false        # 검색 실패
```

- 재귀 함수 이용
  - 아래와 같이 재귀 함수를 이용하여 이진 검색을 구현할 수도 있음
  ```
  def binarySearch2(a, low, high, key) :
      if low > high:
          return False
      else:
          middle = (low + high)
          if key == a[middle]:
              return True
          elif key < a[middle]:
              return binarySearch2(a, low, middle-1, key)
          elif a[middle] < key:
              return binarySearch2(a, middle+1, high, key)
  ```

## 인덱스
- 인덱스라는 용어는 Database에서 유래했으며, 테이블에 대한 동작 속도를 높여주는 자료 구조를 일컫음. Database 분야가 아닌 곳에서는 Look up table 등의 용어를 사용하기도 함
- 인덱스를 저장하는데 필요한 디스크 공간은 보통 테이블을 저장하는데 필요한 디스크 공간보다 작음. 왜냐하면 보통 인덱스는 키-필드만 갖고 있고, 테이블의 다른 세부 항목들은 갖고 있지 않기 때문

- 배열을 사용한 인덱스
  - 대량의 데이터를 매번 정렬하면, 프로그램의 반응은 느려질 수밖에 없음. 이러한 대량 데이터의 성능 저하 문제를 해결하기 위해 배열 인덱스를 사용 가능

## 선택 정렬(Selection Sort)
- 주어진 자료들 중 가장 작은 값의 원소부터 차례대로 선택하여 위치를 교환하는 방식
  - 앞서 살펴본 셀렉션 알고리즘을 전체 자료에 적용한 것

- 정렬 과정
  - 주어진 리스트 중에서 최소값을 찾음
  - 그 값을 리스트의 맨 앞에 위치한 값과 교환
  - 맨 처음 위치를 제외한 나머지 리스트를 대상으로 위의 과정을 반복
  - 미정렬원소가 하나 남은 상황에서는 마지막 원소가 가장 큰 값을 갖게 되므로, 실행을 종료하고 선택 정렬이 완료됨

- 시간 복잡도
  - O(n^2)

- 알고리즘
```
def SelectionSort(a[], a)
    for i from 0 to n-2
        a[i],...,a[n-1] 원소 중 최소값 a[k] 찾음
        a[i]와 a[k] 교환
```

- 구현
```
def selectionSort(a, N):
    for i in range(N-1):
        minIdex = i
        for j in range(i+1, N):
            if a[minIdx] > a[j]:
                minIdx = j
        a[i], a[minIdx] = a[minIdx], a[i]
```

- 저장되어 있는 자료로부터 k번째로 큰 혹은 작은 원소를 찾는 방법을 선택 알고리즘이라 함
  - 최소값, 최대값 혹은 중간값을 찾는 알고리즘을 의미하기도 함

- 선택 과정
  - 셀렉션은 아래와 같은 과정을 통해 이루어짐
    - 정렬 알고리즘을 이용하여 자료 정렬
    - 원하는 순서에 있는 원소 가져오기