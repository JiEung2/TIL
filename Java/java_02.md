## 객체지향 프로그래밍이란? - Object Oriented Programming
- 객체란?
    - 주체가 아닌 것, 주체가 활용하는 것
        - 우리 주변에 있는 모든 것으로 프로그래밍의 대상: 사물, 개념, 논리 ...
- 객체지향 프로그래밍
    - 주변의 많은 걸들을 객체화 해서 프로그래밍 하는 것
    - 객체지향은 객체를 많이 만드는 것을 추천한다

### 객체지향 프로그래밍의 장점
- 블록 형태의 모듈화된 프로그래밍
    - 신뢰성 높은 프로그래밍이 가능
    - 추가/수정/삭제가 용이
    - 재 사용성이 높음

### 현실 세계 객체, 클래스, 프로그램의 객체(instance, object)의 관계
- 현실의 객체가 갖는 속성과 기능은 추상화(abstraction) 되어 클래스에 정의된다.
- 클래스는 구체화 되어 프로그램의 객체(instance, object)가 된다.

- 현실의 객체는 우리가 만지고 느낄 수 있는 것 -> 실생활에 구체화 되어있는 내용
- 객체를 필요할 때마다 매번 처음부터 새로 만들어야 한다면?
    - 실생활에서는 붕어빵 틀, 설계도(blueprint) 사용
    - 설계도는 제품을 만들기 위해 꼭 필요하지만 이를 사용하지는 않고 설계도로 만든 제품 사용
    - 설계도는 하나의 종류(Type)가 되고 설계도를 통해 나온 제품을 객체라고 부르며 주체가 사용

- 추상화와 구체화
    - 추상화는 클래스(멤버 변수, 멤버 메서드)
    - 구체화는 객체의 생성

- 프로그램의 클래스와 객체
    - 클래스
        - 객체를 정의해 놓은 것 즉 객체의 설계도, 틀
        - 클래스는 직접 사용할 수 없고 객체를 만들기 위한 틀을 제공할 뿐
        - `데이터 타입`
    - 객체(instance, object)
        - 클래스를 데이터 타입으로 메모리에 생성되어 실제로 동작하는 것
        - `메모리에 생성된 데이터`

### 객체 생성과 메모리
- JVM의 메모리 구조
    |meta-space|stack|heap|
    |:---:|:---:|:---:|
    |클래스 정보 처리|메서드들의 실행 공간|`객체를 저장`하기 위한 영역|
    |- 타입 정보|- `thread 별`로 별도 관리|- `thread에 의해 공유`|
    |- Field 정보|- 메서드 호출 시 마다 메서드 프레임 적층|- 객체가 생성되고 Garbage Collection에 의해 정리됨|
    |- Method 정보|- 메서드 프레임에 로컬 변수도 쌓이는 구조|-상수 풀|

### 변수의 종류
- 타입에 따른 분류
    - Primitive Type variable
    - Reference Type variable
- 선언 위치에 따른 분류
    |종류|선언 위치|변수종류|
    |:---:|:---:|:---:|
    |멤버변수|클래스 영역(static keyword)|클래스 멤버 변수|
    |"|클래스 영역|인스턴스 멤버 변수|
    |지역변수|함수 내부|지역변수|
    |"|함수 선언부|파라미터 변수|

### 인스턴스 멤버 변수의 특징
- 선언 위치: 클래스 {}영역에 선언
- 변수의 생성: 객체가 만들어질 때 heap에 객체 별로 생성됨

- 변수의 초기화: 타입 별로 default 초기화
- 변수에의 접근: 객체 생성 후(메모리에 올린 후) 객체 이름(소속)으로 접근
    - 객체를 만들 때마다 객체 별로 생성 -> 객체마다 고유한 상태(변수 값) 유지
- 소멸 시점
    - Garbage Collector에 의해 객체가 없어질 때(프로그래머가 명시적으로 소멸시킬 수 없음)

### 클래스 멤버 변수의 특징
- 선언 위치: 클래스 {}영역에 선언되며 static 키워드를 붙임
- 변수의 생성: 클래스 로더에 의해 클래스가 로딩 될 때 heap에 클래스 별로 생성
    - 개별 객체의 생성과 무관하며 모든 객체가 공유하게 됨(공유 변수라고도 불림)

- 변수의 초기화: 타입 별로 default 초기화
- 변수에의 접근: 객체 생성과 무관하게 클래스 이름(소속)으로 접근
    - 객체를 생성하고 객체 이름으로 접근도 가능하나 static에 부합한 표현은 아님
- 소멸 시점
    - 클래스가 언로드 될 때 G.C 발생

### 지역 변수 & 파라미터 변수
- 선언 위치: 클래스 영역의 {} 이외의 모든 중괄호 안에 선언되는 변수들
    - 메서드, 생성자, 초기화 블록
- 변수의 생성: 선언된 라인이 실행될 때
    - 생성 메모리 영역: stack의 메서드 프레임 내부
- 변수의 초기화: 사용하기 전 명시적 초기화 필요
- 변수에의 접근: 외부에서는 접근이 불가하므로 소속 불필요
    - 내부에서는 이름에 바로 접근

- 소멸 시점
    - 선언된 영역인 {}을 벗어날 때

## 메서드
### 메서드 정의와 필요성
- 메서드란?
    - 현실의 객체가 하는 동작을 프로그래밍 화
    - 어떤 작업을 수행하는 명령문의 집합

- 메서드를 작성하는 이유
    - 반복적으로 사용되는 코드의 중복 방지
        - DRY: Don't Repeat Yourself!
        - WET: We Enjoy Typing or Writing Everything Twice
    - 코드의 양을 줄일 수 있고 유지 보수가 용이함

- 메서드의 작성 방법
    - 제한자 리턴_타입 메서드이름(타입 변수_명, 타입 변수_명...) -> 선언부
    - {} -> 구현부

    - 어떤 값을 입력 받아서 -> 파라미터(생략 가능)
    - 작업을 진행하고 -> 실행문장
    - 결과를 돌려주는 역할 ->리턴 값(생략 가능)

### 선언부
- 리턴타입
    - 메서드를 호출한 곳으로 반환되는 값의 타입으로 아무것도 리턴하지 않을 경우 void
    - 결과를 받을 때 묵시적 형변환 적용
    - 리턴 타입은 하나만 적용 가능

- 메서드 이름은 수행하는 작업을 쉽게 파악하도록 의미 있는 이름 사용
- 파라미터 목록
    - 메서드 호출 시점에 넘겨줘야 하는 변수들로 넘겨줄 정보가 없을 경우 생략 가능
    - 파라미터 전달 시 묵시적 형변환 적용

### Variable arguments
- 메서드 선언 시 동일 타입의 인자가 몇 개 들어올 지 예상할 수 없을 경우 (또는 가변적)
    - 배열 타입을 선언할 수 있으나 -> 메서드 호출 전 배열을 생성, 초기화 해야 하는 번거로움
    - ...을 이용해 파라미터를 선언하면 호출 시 넘겨준 값의 개수에 따라 자동으로 배열 생성 및 초기화

### 구현부
- 구현부는 중괄호 내에서 처리해야 하는 내용 즉 비즈니스 로직 작성
- 마지막에는 선언된 리턴 타입에 해당하는 값을 return 문장과 함께 반환해야 함
    - 값 반환 시에는 묵시적 형 변환 적용
    - 리턴 타입이 void여서 반환할 값이 없을 경우 return 문장 생략 가능
    - 메서드 수행 도중 return 문장을 만나거나 마지막 문장을 수행하는 경우 메서드는 종료
        - 조건문을 이용해서 return 할 경우 모든 조건에서 return 필수

### 메서드 호출
- 메서드를 호출할 때는 메서드의 선언부에 맞춰 호출해야 함
    - 메서드 이름: 반드시 동일
    - 파라미터: 선언된 파라미터의 개수는 반드시 동일, 타입은 promotion 적용 가능

- 메서드 접근
    - 멤버 변수와 마찬가지로 static 또는 non static 상태를 구분해서 호출
    - static member는 소속은 클래스이며 같은 클래스에서는 바로 호출, 다른 클래스에서는 클래스이름.멤버이름으로 호출 가능
    - non static member는 객체 소속이며 같은 클래스에서는 바로 호출, 다른 클래스에서는 객체 생성 후 객체이름.멤버이름으로 호출 가능
    - 그냥 늘 하던대로 그렇게

### class 멤버와 instance 멤버간의 참조와 호출 -> 공부안하면 헷갈리니까 유의
- 가장 중요한 것은 호출하려는 멤버가 메모리에 있는가?
    - 메모리에 있으면 호출 가능
    - 메모리에 없으면 호출 불가 - 먼저 메모리에 로딩 후 사용해야 함
- static member -> 언제나 메모리에 있음
    - 클래스 로딩 시 자동 등록
- instance member -> 객체 생성 전에는 메모리에 없음
    - 객체 생성 시 모든 일반 멤버들은 메모리에 생성
    - 객체 즉 레퍼런스를 통해서 접근
    
### 메서드 호출 스택
- 스택(stack)
    - First in Last Out의 구조
- 메서드 호출 스택
    - 각각의 메서드 호출 시 마다 메서드 동작을 위한 메모리 상자를 하나씩 할당
        - 상자 내부에 메서드를 위한 파라미터 변수 등 로컬 변수 구성
    - A 메서드에서 새로운 메서드 B 호출 시 B 실행을 위한 메모리 상자를 쌓음
        - 언제나 맨 위에 있는 메모리 상자(B)만 활성화
        - 이 때 A 메서드는 동작이 끝나지 않고 잠시 정지된 상태
        - B가 리턴하게 되면 B를 위한 상자가 제거되며 메모리 반납
        - 비로서 A가 최상위가 되서 다시 동작 재개

### 기본형 변수와 참조형 변수 (중요)
- 메서드 호출 시 파라미터로 입력된 값을 복사해서 전달
- Java는 call by value!! Value의 정체는?
```java
public class CallByTest{
    int memberVar = 10;

    static void change1(int var) {
        var += 10;
        System.out.printf("change1 : %d%n", var);
    }
    static void change2(CallByTest cbtl){
        cbtl.memberVar += 100;
        System.out.printf("change2 : %d%n", cbtl.memberBar);
    }

    public static void main(String[] args){
        CallByTest cbt = new CallByTest();
        cbt.memberVar = 5;
        System.out.printf("change1 호출 전 memberVar: %d%n", cbt.memberVar);
        change1(cbt.memberVar);
        System.out.printf("change1 호출 후 memberVar: %d%n", cbt.memberVar);
        change2(cbt);
        System.out.printf("change2 호출 후 memberVar: %d%n", cbt.memberVar);
    }
}
```

### 메서드 오버로딩 (중요)
- overloading: 동일한 기능을 수행하는 메서드의 추가 작성
    - 일반적으로 메서드 이름은 기능별로 의미 있게 정함
    - 동일한 기능을 여러 형태로 정의해야 한다면?

- println 메서드 고찰
    - public void println(int x)
    - public void println(char x)
    - public void println(String x)
    - -> 사실은 다른 메서드 틀

- 무언가를 출력하는 메서드
    - 출력할 대상은 각각 다르지만 콘솔에 출력하는 방법은?

- 메서드 오버로딩의 장점
    - 기억해야 할 메서드가 감소하고 중복 코드에 대한 효율적 관리 가능

### 메서드 오버로딩 방법
- 메서드 이름은 동일
- 파라미터 개수 또는 순서, 타입이 달라야 할 것
    - 파라미터가 같으면 중복 선언 오류
- 리턴 타입은 의미 없음
```java
int add(int a, int b){return a + b;} 
int add(int x, int y){return x + y;}
//위 둘은 오버로딩o

int add(int a, int b){return a + b;}
long add(int a, int b){return a + b;}
//위 둘은 오버로딩o

long add(long a, int b){return a + b;}
long add(int a, long b){return a + b;}
//위 둘은 오버로딩x 오류 발생
```