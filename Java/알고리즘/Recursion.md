# 재귀 호출
## 반복(Iteration)과 재귀(Recursion)
- 반복과 재귀는 유사한 작업을 수행할 수 있다.
- 반복은 수행하는 작업이 완료될 때까지 계속 반복
  - 루프(for/while, do~while 구조)
- 재귀는 주어진 문제의 해를 구하기 위해 동일하면서 더 작은 문제의 해를 이용하는 방법
  - 하나의 큰 문제를 해결할 수 있는 (해결하기 쉬운) 더 작은 문제로 쪼개고 결과들을 결합한다.
  - 재귀 함수로 구현

**재귀함수의 설계**
1. 함수에 대한 정의(역할)를 명확히
2. 함수 수행에 필요한 결정적 요인, 값 설계 => 매개변수
3. 재귀의 종료조건

### 재귀 함수(recursive function)
- 함수 내부에서 직접 혹은 간접적으로 자기 자신을 호출하는 함수
- 일반적으로 재귀적 정의를 이용해서 재귀 함수를 구현
- 따라서, 기본 부분(basis part)(기저조건)와 유도 부분(inductive part)(재귀 파생)로 구성
- 재귀적 프로그램을 작성하는 것은 반복 구조에 비해 간결하고 이해하기 쉬움
  - 그러나, 재귀에 대해 익숙하지 않은 개발자들은 재귀적 프로그램이 어렵다고 느낌
- 함수 호출은 프로그램 메모리 구조에서 스택을 사용
- 따라서 재귀 호출은 반복적인 스택의 사용을 의미하여 메모리 및 속도에서 성능저하가 발생

### 팩토리얼 재귀 함수
- 재귀적 정의
```
Basis rule:
    N <= 1 경우, n = 1
Indeuctive rule:
    N > 1, N! = n X (n - 1)!
```

- n!에 대한 재귀함수
```java
int fact(int n){
    if(n <= 1) return 1;
    else return n * fact(n - 1);
}

```

- n개 중 k개를 뽑는 조합의 경우의 수 계산을 재귀로 작성해보자
```java
public static int f(int n, int k){
    if(k == 1) return n;
    if(n == k) return 1;

    return f(n-1, k-1) + f(n-1, k)
}
```

### 반복 또는 재귀?
- 해결할 문제를 고려해서 반복이나 재귀의 방법을 선택
- 재귀는 문제 해결을 위한 알고리즘 설계가 간단하고 자연스러움
  - 추상 자료형(List, tree 등)의 알고리즘은 재귀적 구현이 간단하고 자연스러운 경우가 많음
- 일반적으로, 재귀적 알고리즘은 반복(Iterative) 알고리즘보다 더 많은 메모리와 연산을 필요로 함
- 입력 값 n이 커질수록 재귀 알고리즘은 반복에 비해 비효율적일 수 있다.

||재귀|반복|
|:---:|:---:|:---:|
|종료|재귀 함수 호출이 종료되는 베이스 케이스|반복문의 종료 조건|
|수행 시간|(상대적) 느림|빠름|
|메모리 공간|(상대적) 많이 사용|적게 사용|
|소스 코드 길이|짧고 간결|길다|
|소스 코드 형태|선택 구조(if...else)|반복 구조(for, while)|
|무한 반복시|스택 오버플로우|CPU를 반복해서 점유|

### 재귀 호출 - 피보나치 수열
```java
fibo(n):
    if(n < 2) return n;
    else return fibo(n - 1) + fibo(n - 2);
```

- 앞의 예에서 피보나치 수를 구하는 함수를 재귀함수로 구현한 알고리즘은 문제가 존재
- 엄청난 중복 호출이 존재

### 재귀 호출 응용 - 하노이탑
