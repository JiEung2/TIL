# APS

## 완전 검색(Exhaustive Search)
- 완전 검색 방법은 문제의 해법으로 생각할 수 있는 모든 경우의 수를 나열해보고 확인하는 기법
- Brute-force 혹은 generate-and-test 기법이라고도 불림
- 모든 경우의 수를 테스트한 후, 최종 해법을 도출
- 상대적으로 빠른 시간에 문제 해결(알고리즘 설계) 가능
- 일반적으로 경우의 수가 상대적으로 작을 때 유용
- 모든 경우의 수를 생성하고 테스트하기 때문에 수행 속도는 느리지만, 해답을 찾아내지 못할 확률이 작음
- 검정 등에서 주어진 문제를 풀 때, 우선 완전 검색으로 접근하여 해답을 도출한 후, 성능 개선을 위해 다른 알고리즘을 사용하고 해답을 확인하는 것이 바람직


- 많은 종류의 문제들이 특정 조건을 만족하는 경우나 요소를 찾는 것
- 또한, 이들은 전형적으로 순열, 조합, 그리고 부분집합과 같은 조합적 문제들과 연관된다.

### 고려할 수 있는 모든 경우의 수 생성하기
- 6개의 숫자로 만들 수 있는 모든 숫자 나열(중복 포함)
- <모든 경우의 순열 나열>

### 순열(Permutation)
- 서로 다른 것들 중 몇 개를 뽑아서 한 줄로 나열하는 것
- 서로 다른 n개 중 r개를 택하는 순열은 `nPr`과 같이 표현
- 그리고 nPr은 다음과 같은 식이 성립  
```
nPr = n * (n-1) * (n-2) * ... * (n-r+1)
```
- nPn = n!이라고 표기하며 팩토리얼이라고 부름
- 다수의 알고리즘 문제들은 순서화된 요소들의 집합에서 최선의 방법을 찾는 것과 관련 있음
    - ex) TSP(Traveling Salesman Problem)
- N개의 요소들에 대해서 n!개의 순열들이 존재

### 순열 구현 - 반복문
- ex) {1, 2, 3}을 포함하는 모든 순열을 생성
- nPr 에서 r은 반복문 수 결정
- 단 r이 가변적일 때는 재귀로 구현 가능
- 반복문을 통한 순열 생성
```
for i from 1 to 3
    for j from 1 to 3
        if j != i then
            for k from 1 to 3
                if k != i and k !- j then
                    print i, j, k
                end if
            end for
        end if
    end for
end for
```

- 재귀 호출을 통한 순열 생성
```
numbers[]: 순열 저장 배열
isSelected[]: 인덱스에 해당하는 숫자가 사용 중인지 저장하는 배열
perm(cnt) // cnt: 현재까지 뽑은 순열 수의 개수(자리수)
    if cnt == 3
        순열 생성 완료
    else
        for i from 1 to 3
            if isSelected[i] == true then continue
            numbers[cnt] <- i
            isSelected[i] <- true
            perm(cnt+1)
            isSelected[i] <- false
        end for
```

### 완전 검색 활용
- 주사위 던지기1
    - 주사위를 3번 던져서 나올 수 있는 모든 경우  
        -> `중복` 순열

- 주사위 던지기 2
    - 주사위를 3번 던져서 모드 다른 수가 나올 수 잇는 모든 경우
    - 단, 123,132,321 같은 결과는 서로 다른 경우로 봄  
        -> 그냥 순열


## 완전 검색 - 조합
### 조합
- 서로 다른 n개의 원소 중 r개를 순서 없이 골라낸 것을 조합(combination) 이라고 부름
- 조합의 수식  
```
nCr = n! / (n-r)!r!, (n >= r)
nCr = n-1Cr-1 + n-1Cr ---> 재귀적 표현
nC0 = 1
```

### 조합 구현 - 반복문
- ex) {1,2,3,4}중 원소 3개를 포함하는 모든 조합을 생성
- 반복문을 통한 조합 생성
```
for i from 1 to 4
    for j from i+1 to 4
        for k from j+1 to 4
            print i, j, k
        end for
    end for
end for
```

### 조합 구현 - 재귀
- 재귀 호출을 이용한 조합 생성 알고리즘
```
nCr -> n개의 원소 중 r개 원소를 갖는 조합 생성
input[]: n개의 원소를 가지고 있는 배열
numbers[]: r개의 크기의 배열, 조합이 저장될 배열

comb(cnt, start) // cnt: 현재까지 뽑은 조합 원소 개수, start: 조합 시도할 원소의 시작 인덱스
    if cnt == r
        조합 생성 완료
    else
        for i from start to n-1
            numbers[cnt] <- input[i];
            comb(cnt+1, i+1);
        end for
end comb()
```

### 완전 검색 활용
- 주사위 던지기3
    - 주사위를 3번 던진 결과가 다음과 같이 중복 되는 경우를 제외하고 나올 수 있는 모든 경우
    - (112,121,211 -> 중복되는 경우)

- 주사위 던지기4
    - 주사위를 3번 던져서 모두 다른 수가 나올 수 있는 모든 경우
    - 단, 123,132,321와 같은 경우는 중복되는 경우로 봄


## 완전 검색 - 부분 집합
### 부분 집합
- 집합에 포함된 원소들을 선택하는 것
- 다수의 중요 알고리즘들이 원소들의 그룹에서 최적의 부분 집합을 찾는 것
- 부분집합의 수
    - 집합의 원소가 n개일 때, 공집합을 포함한 부분집합의 수는 2^n개
    - 이는 각 원소를 부분집합에 포함시키거나 포함시키지 않는 2가지 경우를 모든 원소에 적용한 경우의 수와 같음

### 부분 집합 구현 - 반복문
- ex) {1,2,3} 집합의 모든 부분집합(Power Set) 생성
- 반복문을 통한 부분집합 생성
```
for i in 1 -> 0
    selected[1] <- i
    for j in 1 -> 0
        selected[2] <- j
        for k in 1 -> 0
            selected[3] <- k
            for m in 1 -> 3
                if selected[m] == 1 then
                    print m

```

### 부분 집합 구현 - 재귀
- 입력된 숫자로 구성된 집합의 모든 부분집합(Power Set) 생성
- 재귀적 구현을 통해 생성하는 방법
    - 각 원소를 부분집합에 포함/비포함의 형태로 재귀적 구현을 함
    ```
    input[]: 숫자 배열
    isSelected[]: 부분집합에 포함/비포함 여부를 저장한 배열

    generateSubSet(cnt)     // cnt: 현재까지 처리한 원소 개수
        if(cnt == N)
            부분집합 완성
        else
            isSelected[cnt] <- true // 지정된 요소 선택(포함)
            generateSubSet(cnt + 1)
            isSelected[cnt] <- false // 지정된 요소 비선택(비포함)
            generateSubSet(cnt + 1)
    ```

### 완전 검색 - 부분 집합의 합
- 유한 개의 정수로 이루어진 집합이 있을 때, 이 집합의 부분집합 중에서 그 집합의 원소를 모두 더한 값이 0이 되는 경우가 있는지를 알아내는 문제
- 예를 들어, {-7, -3, -2, 5, 8}라는 집합이 있을 때, {-3, -2, 5}는 이 집합의 부분집합이면서 -3 + -2 + 5 = 0이므로 이 경우의 답은 참이 됨
- 완전검색 기법으로 부분집합 합 문제를 풀기 위해서는, 우선 집합의 모든 부분집합을 생성한 후에 각 부분집합의 합을 계산해야 함

### 부분 집합 응용 - 바이너리 카운팅
- 원소 수에 해당하는 n개의 비트열을 이용함
- n번째 비트 값이 1이면 n번째 원소가 포함되었음을 의미

